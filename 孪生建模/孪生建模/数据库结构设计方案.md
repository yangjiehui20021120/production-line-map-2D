# 侧墙生产线孪生实体建模数据库结构设计方案

## 1. 编制目的

依据 `03数字孪生实体数据目录.md` 中对 TwinObject、MBOM、Scene、Modality、Assignment 等实体的建模定义，结合 Draco、TimescaleDB、PostgreSQL、Neo4j、MinIO 五类数据库/组件的能力，设计可落地的多模数据库结构，支撑侧墙生产线数字孪生的主数据、关系、时序与非结构化数据治理。

## 2. 实体族概述

- **资源层 (TwinObject, Role, Assignment)**：设备、工位、人员、角色及岗位指派，字段包含统一 URN、子类型、能力、组织归属等元数据。  
- **工艺层 (MBOM_Root/Route/Takt/Process/Step)**：产品工艺结构，包含节拍、工序、工步等多层级关系。  
- **执行层 (Scene, ModalityBinding)**：工件在节拍上的执行实例及模态绑定配置。  
- **运行层 (ModalData)**：由 TwinObject×Scene×Modality 三锚点定位的实时/过程数据，含 value、observedAt、provenance 等字段。  

上述核心字段在数据目录中均有定义，例如 TwinObject 共享字段 `id/subType/twinType` 以及设备特有字段 `equipmentType/deployedAt`，为结构化建模提供约束依据。

## 3. 多数据库总体架构

| 层级 | 组件 | 职责 | 主要对象 |
|------|------|------|----------|
| Context API 层 | Draco (NGSI-LD Broker) | 承载 NGSI-LD 实时上下文，向上游应用提供查询/订阅接口 | 全量实体实时态 |
| 关系主数据层 | PostgreSQL | 按实体族落地第三范式表，保证主数据一致性与可追溯 | TwinObject、Role、Assignment、MBOM、Scene、Modality、Binding |
| 时序运行层 | TimescaleDB | 以 ModalData 为核心构建 Hypertable，支撑秒级/毫秒级插入、聚合 | ModalData 数值/状态点 |
| 图谱关系层 | Neo4j | 显式建模实体间拓扑/流程/责任关系，支持复杂路径查询 | OrgUnit、Station、Process/Step 等关系 |
| 非结构化层 | MinIO | 存储与 ModalData/Scene 关联的波形、图像、3D 点云等文件，提供对象 URL | 高频原始数据、报告、附件 |

### 3.1 Draco → 数据湖泊入口

- 统一接收 NGSI-LD `POST/PUT/PATCH` 的实体事件，维护实时上下文。  
- 通过订阅规则向 Kafka/MQ 推送更新，驱动下游 PostgreSQL（主数据）、TimescaleDB（时序）、Neo4j（关系）以及 MinIO（对象）的同步管道。  
- 使用 `id` (URN) 作为跨库主键，确保实体在五个存储间可对齐。

### 3.2 数据同步策略

1. **主数据镜像**：Draco 订阅 TwinObject/MBOM/Scene 等非高频实体的 `EntityChange`，由 CDC 任务写入 PostgreSQL。  
2. **时序直写**：ModalData 事件经 Draco Stream 输出，流式写入 TimescaleDB Hypertable；若 value 包含大对象，则将文件上传 MinIO，把对象 URL 写回 ModalData 记录。  
3. **关系投影**：PostgreSQL 中的关系变更通过 Debezium→Kafka→Neo4j Connector 生成/更新节点与边。  
4. **对象归档**：生产的波形/图像先落 MinIO，元数据（尺寸、checksum）回写 PostgreSQL/Neo4j 供溯源。

## 4. 各数据库结构设计

### 4.1 Draco (Context Broker)

- **实体类型集合**：`TwinObject`, `Role`, `Assignment`, `MBOM`, `Scene`, `Modality`, `ModalityBinding`, `ModalData`。  
- **命名规范**：保留源文档中 `urn:ngsi-ld:{EntityType}:{Identifier}` 形式，作为多数据库的统一主键。  
- **索引策略**：针对 `type`、`subType`、`relationships.object` 建立二级索引，支撑按实体族/锚点快速检索。  
- **订阅通道**：  
  - `TwinObject/*` → PostgreSQL 主数据同步  
  - `ModalityBinding/*` → Neo4j/Timescale 配置同步  
  - `ModalData/*` → TimescaleDB 插入通道（批量/流式）

### 4.2 PostgreSQL 主数据模型

#### 4.2.1 命名与分表策略

- Schema 按层级拆分：`resource`, `process`, `execution`, `modality`, `assignment`。  
- 所有表主键均为 `id UUID/URN`；可增加 `surrogate bigserial` 供内部引用，但对外只暴露 URN。  
- 针对变更频率较低的实体（OrgUnit, Station, AutoEquipment 等）采用 SCD Type 2 表，记录 `valid_from/valid_to`。

#### 4.2.2 示例表结构

```sql
CREATE TABLE resource.twin_object (
  id text PRIMARY KEY,
  subtype text NOT NULL,
  name text NOT NULL,
  twin_type text NOT NULL,
  function_category text NOT NULL,
  attributes jsonb,
  location geometry(Point, 4490),
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

CREATE TABLE resource.station (
  id text PRIMARY KEY REFERENCES resource.twin_object(id),
  station_category text NOT NULL,
  area_code text,
  zone_id text,
  capacity_wip smallint,
  station_location text REFERENCES resource.org_unit(id)
);
```

- `attributes` 保存各子类型特有属性（如 AutoEquipment 的 `controllerType`, `supportedProcesses` 等）。  
- `process.mbom_process`、`process.mbom_step` 等表按 MBOM 多层结构展开，同时保存 `part_of_*` 外键。  
- `execution.scene`、`modality.modality_binding` 表存储 Scene/Binding 的结构化属性；`scene.step_log` 采用 JSONB + GIN 索引或子表拆解。  
- `assignment.assignment` 表实现岗位指派的时态记录，字段对齐源文档 `assigneeId/roleId/orgId/validFrom/validTo/assignmentStatus/...`。

#### 4.2.3 视图与物化视图

- `vw_station_equipment`：关联 Station 与部署设备。  
- `vw_process_requirement`：工步所需资源、模态集合，供排产/校验。  
- `mv_active_assignment`：缓存当前有效的人员指派，提高场景调度效率。

### 4.3 TimescaleDB (ModalData 时序层)

#### 4.3.1 Hypertable 设计

```sql
CREATE TABLE runtime.modal_data (
  id text PRIMARY KEY,
  ref_twin text NOT NULL,
  ref_scene text NOT NULL,
  ref_modality text NOT NULL,
  observed_at timestamptz NOT NULL,
  sequence_number int,
  value_numeric double precision,
  value_text text,
  value_json jsonb,
  quality_tag text NOT NULL,
  provenance jsonb NOT NULL,
  related_data text[],
  metadata jsonb,
  minio_object_url text
);

SELECT create_hypertable('runtime.modal_data', 'observed_at', chunk_time_interval => INTERVAL '1 day');
SELECT create_index('runtime.modal_data', 'ref_twin, observed_at');
SELECT create_index('runtime.modal_data', 'ref_scene, observed_at');
```

- `value_*` 字段根据 `valueType` 选择写入；也可改用 Timescale 的多列策略或 JSONB。  
- `minio_object_url` 关联 MinIO 对象。  
- 使用 Continuous Aggregate `ca_modaldata_hourly` 聚合 `avg/max/min/stddev`，支撑 KPI 计算。  
- 开启压缩策略（保留近 30 天明细，历史压缩/分区归档）。

#### 4.3.2 数据写入通道

- ModalData 由 Draco 流式推送至写入服务，采用 COPY/批量 Insert。  
- 对高频模态（如 `WeldingCurrent_Auto`）启用 TimescaleDB Kafka Connector 或 Telegraf→Timescale Sink。  
- 数据治理规则：  
  - 写入时校验 `qualityTag`；  
  - provenance 中记录 `sourceTwinId/method/swVersion`；  
  - 若 `qualityTag` ≠ `OK`，自动同步告警到 Neo4j 事件节点。

### 4.4 Neo4j 图数据库

#### 4.4.1 节点模型

| Label | 属性 | 对应实体 |
|-------|------|----------|
| `OrgUnit` | `id`, `orgUnitType`, `orgLevel` | OrgUnit |
| `Station` | `id`, `stationCategory`, `areaCode` | Station |
| `Position` | `id`, `positionType` | Position |
| `AutoEquipment` | `id`, `equipmentType`, `model` | 自动化设备 |
| `Person` | `id`, `skills` | 人员 |
| `Role` | `id`, `name` | 角色 |
| `Assignment` | `id`, `validFrom`, `validTo` | 指派 |
| `MBOMProcess` | `id`, `procSeq`, `procKind` | 工序 |
| `MBOMStep` | `id`, `stepSeq`, `stationCode` | 工步 |
| `Scene` | `id`, `sceneStatus` | 场景 |
| `Modality` | `id`, `category`, `valueType` | 模态 |
| `ModalityBinding` | `id`, `sampleRate` | 绑定 |

#### 4.4.2 边关系

- `(:OrgUnit)-[:PARENT_OF]->(:OrgUnit)`  
- `(:Station)-[:LOCATED_IN]->(:OrgUnit)`，`(:Station)-[:USES]->(:AutoEquipment)`  
- `(:Person)-[:ASSIGNED_AS {roleId, shiftId}]->(:Role)` (通过 Assignment 节点串联)  
- `(:MBOMProcess)-[:NEXT_PROCESS]->(:MBOMProcess)`、`(:MBOMProcess)-[:HAS_STEP]->(:MBOMStep)`  
- `(:Scene)-[:EXECUTES]->(:MBOMTakt)`，`(:Scene)-[:INVOLVES]->(:Person)`  
- `(:ModalityBinding)-[:MEASURES]->(:Modality)`，`(:ModalityBinding)-[:ATTACHED_TO]->(:TwinObject)`  

建立复合索引：`CREATE INDEX orgunit_id IF NOT EXISTS FOR (n:OrgUnit) ON (n.id);` 等。  
通过 APOC/Graph Data Science 可执行路径分析（如设备→工位→工序→场景→质量结果）。

### 4.5 MinIO 对象存储

- **Bucket 规划**  
  - `modal-raw/{year}/{month}/{day}/ref_twin/`：高频波形（如焊接电流）  
  - `modal-profile/`：统计曲线、谱图  
  - `scene-media/scene_id/`：工步视频、图片  
  - `qc-attachments/`：检具测量报告、点云
- **命名策略**：`{modalityCode}/{sceneId}/{sequence}.{ext}` 与 ModalData URN 保持可逆映射。  
- **元数据治理**：上传后写入对象元数据（content-type、checksum、observedAt、refTwin、refScene、refModality），并回写 TimescaleDB/Neo4j。

### 4.6 面向 T1 技术规格书的扩展

《T1_数字孪生管理平台_技术规格书_V2.0》要求平台覆盖 Fiware 六层架构与 13 个功能点。基于现有五大数据组件，需要新增/强化以下数据支撑：

| 组件 | Schema/存储单元 | 关键字段 | 覆盖功能/层级 |
|------|----------------|----------|---------------|
| PostgreSQL `integration` | `iot_device`, `iot_channel`, `semantic_mapping` | `protocol`, `agent_endpoint`, `mapping_expression`, `twin_ref` | L1 感知层、F3 语义锚定、F10 批量接入 |
| PostgreSQL `context` | `subscription`, `notification_log`, `schema_registry` | `subscription_body`, `callback_url`, `status`, `contract_code`, `schema_json` | L2 上下文层、F1/F2/F4 |
| PostgreSQL `security` | `user_account`, `rbac_role`, `rbac_permission`, `role_permission` | `username`, `org_scope`, `permission_code` | L4 安全控制层、F13 |
| PostgreSQL `automation` | `rule_definition`, `rule_action`, `rule_audit` | `rule_name`, `condition`, `action_type`, `perseo_rule_id` | L6 自动化层、F12 |
| TimescaleDB `monitoring` | `api_metric`, `subscription_metric`, `rule_event`（Hypertable） | `latency_ms`, `status_code`, `topic`, `result` | L3 数据层（监控）、F7/F8/F9 |
| Neo4j | `(:IoTDevice)`, `(:Subscription)`, `(:Rule)` 及 `[:FEEDS]`, `[:WATCHES]`, `[:TRIGGERS]` | `agent`, `topic`, `actionTarget` | F3/F4/F6/F12 |
| MinIO | `contracts/`, `rules/`, `mock-data/` 目录 | 对象元数据 `contract_code`, `rule_version` | F2/F5/F12 |

#### 4.6.1 示例表结构

```sql
CREATE TABLE integration.iot_device (
  id text PRIMARY KEY,
  protocol text NOT NULL,           -- JSON/UL/OPC-UA
  agent_endpoint text NOT NULL,
  twin_ref text NOT NULL,           -- TwinObject URN
  status text NOT NULL DEFAULT 'Active',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE integration.semantic_mapping (
  id bigserial PRIMARY KEY,
  device_id text NOT NULL REFERENCES integration.iot_device(id),
  modality_id text NOT NULL,
  mapping_expression text NOT NULL, -- JMESPath / JS 脚本
  version text NOT NULL,
  effective_from timestamptz NOT NULL,
  effective_to timestamptz
);

CREATE TABLE context.schema_registry (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  contract_code text NOT NULL,        -- 00~08 契约
  version text NOT NULL,
  schema_json jsonb NOT NULL,
  checksum text NOT NULL,
  status text NOT NULL DEFAULT 'active',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE context.notification_log (
  id bigserial PRIMARY KEY,
  subscription_id text NOT NULL,
  entity_type text,
  event_type text,
  payload jsonb,
  status text NOT NULL,
  delivered_at timestamptz,
  created_at timestamptz DEFAULT now()
);

CREATE TABLE security.user_account (
  id uuid PRIMARY KEY,
  username text UNIQUE NOT NULL,
  password_hash text NOT NULL,
  org_scope text,
  status text NOT NULL DEFAULT 'Active',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE automation.rule_definition (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  rule_name text NOT NULL,
  condition text NOT NULL,
  action jsonb NOT NULL,
  perseo_rule_id text,
  monitored_modality text,
  target_entity text,
  status text NOT NULL DEFAULT 'enabled',
  created_at timestamptz DEFAULT now()
);

CREATE TABLE monitoring.api_metric (
  time timestamptz NOT NULL,
  api_name text NOT NULL,
  latency_ms integer,
  status_code integer,
  consumer text,
  PRIMARY KEY (time, api_name)
);
SELECT create_hypertable('monitoring.api_metric', 'time', chunk_time_interval => INTERVAL '1 day');
```

#### 4.6.2 功能映射

- **L1 感知层**：`integration.iot_device`、`semantic_mapping` 与 Neo4j `(:IoTDevice)-[:FEEDS]->(:TwinObject)` 结合，支撑 F3 语义锚定和 F10 批量接入。  
- **L2 上下文层**：`context.subscription`/`notification_log` 记录 Scorpio 订阅与通知链路，`schema_registry` 管理 9 份契约 JSON Schema，满足 F1/F2/F4。  
- **L3 数据层**：TimescaleDB `monitoring.*` Hypertable 聚合 API、订阅与规则事件指标，支撑 F7 运维监控、F8 历史查询、F9 数据质量。  
- **L4 安全层**：`security.*` 表为 JWT/RBAC 提供持久化，配合 TimescaleDB 增设 `auth_metric` 记录登录事件，覆盖 F13。  
- **L5 可视化层**：基于 PostgreSQL 物化视图 `mv_dashboard_entities`/`mv_notification_stats`，向前端 F5/F7 提供仪表盘数据；MinIO `mock-data/` 存储前端 Mock 资源。  
- **L6 自动化层**：`automation.rule_definition` + MinIO `rules/` + Neo4j `(:Rule)-[:TRIGGERS]->(:Scene)` 实现规则闭环，Perseo 运行态引用这些元数据，满足 F12。

## 5. 跨库协同与关键设计决策

1. **统一 ID 体系**：所有表、节点、对象均以 URN 作为唯一主键；PostgreSQL 提供 `urn_uuid()` 视图，便于与业务系统联接。  
2. **多模态查询**：  
   - 实时查询 → Draco；  
   - 历史宽表 → PostgreSQL 物化视图；  
   - 时序分析 → TimescaleDB Continuous Aggregate；  
   - 关系追踪 → Neo4j 路径查询；  
   - 大对象下载 → MinIO 预签名 URL。  
3. **数据血缘**：ModalData `provenance` 保存采集源，Neo4j 增加 `(:ModalData)-[:RECORDED_BY]->(:ModalityBinding)` 边，实现端到端追溯。  
4. **性能策略**：  
   - Timescale 采用 1 天 chunk + 30 天内热数据未压缩；  
   - PostgreSQL 热表启用分区（按 orgUnit/产品）；  
   - Neo4j 使用关系型 CDC 批量 Upsert，避免重复节点；  
   - MinIO 配置版本控制与生命周期（例如 180 天后转归档）。
5. **安全与权限**：  
   - Draco 暴露细粒度订阅权限；  
   - PostgreSQL/Timescale 使用 Row Level Security (RLS) 对 orgUnit、角色隔离；  
   - Neo4j 利用 Role-Based Access，限制写操作；  
   - MinIO 通过 IAM Policy 限定 bucket 访问。

## 6. 实施路线

1. **数据目录到 PostgreSQL**：编写 Schema Migration（Liquibase/Flyway），导入现有实体清单。  
2. **Draco 订阅配置**：根据实体类型设置订阅规则，落地 MQTT/Kafka 通道。  
3. **Timescale 流式写入**：部署 Ingest Service，解析 ModalData 事件写入 Hypertable。  
4. **Neo4j 图谱构建**：初始装载各实体关系，建立定期同步 Job；引入图算法（关键路径、资源冲突）。  
5. **MinIO 对象策略**：制定命名规范与生命周期策略，开发 SDK/服务封装上传下载。  
6. **验证与优化**：通过典型业务场景（如工序追溯、焊接质量分析）进行端到端验证。

## 7. 参考

```
117:243:03数字孪生实体数据目录.md
TwinObject核心字段、Station/AutoEquipment特有字段等定义
```

```
423:770:03数字孪生实体数据目录.md
MBOM层级、Scene、Modality/Binding、ModalData、Assignment 字段定义
```

```
1:1768:T1_数字孪生管理平台_技术规格书_V2.0.md
Fiware 六层、功能映射、契约与组件要求
```


